uuid-ossp TO GENERATE RANDOM UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";


1. TABLES

PATIENTS TABLE

create table patient(
id uuid primary key,
name varchar(100) not null,
email varchar(100) not null unique,
pass varchar(255) not null unique,
phone varchar(15),
dob date,
gender varchar(2) check (gender in ('M', 'F', 'Z')),
blood varchar(4) check (blood in ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-')),
past varchar(255),
address varchar(100),
createdAt date,
updatedAt date);



DOCTORS TABLE

create table doctor(
id uuid primary key,
name varchar(100) not null,
email varchar(100) not null unique,
password varchar(255) not null,
phone varchar(15),
dob date,
gender varchar(2) check (gender in ('M', 'F', 'Z')),
blood varchar(4) check (blood in ('A+', 'A-', 'B+', 'B-', 'O+', 'O-', 'AB+', 'AB-')), 
address varchar(100),
specialty varchar(20),
bmdc varchar(20),
createdAt date,
updatedAt date);



DOCTOR SLOTS TABLE

create table doctor_slot(
doctor_id uuid unique not null references doctor(id) on delete cascade,
slotid uuid unique,
dateOfSlot date,
startTime time,
endTime time,
status numeric check (status in (0, 1)),
createdAt date,
updatedAt date);



DOCTOR PATIENT LIST TABLE

create table doctor_patient(
doctor_id uuid not null references doctor(id) on delete cascade,
patient_id uuid not null references patient(id) on delete cascade,
dateOfAssignment date not null);

alter table doctor_patient
add constraint unq_constraint unique(doctor_id, patient_id);



APPOINTMENTS TABLE

create table appointment(
doctor_id uuid not null references doctor(id) on delete cascade,
patient_id uuid not null references patient(id) on delete cascade,
prescription varchar(255),
dateOfAppointment date not null,
slotid uuid references doctor_slot(slotid) on delete cascade,
status varchar(30) check (status in ('Scheduled', 'Complete')),
createdAt date,
updatedAt date);



RATINGS TABLE

create table doctor_rating(
doctor_id uuid not null references doctor(id) on delete cascade,
numratings numeric,
sumratings numeric,
average numeric,
createdAt date,
updatedAt date);

alter table doctor_rating
add constraint unq1_constraint unique(doctor_id);




2. TRIGGERS

TRIGGER TO CREATE ENTRY IN DOCTOR_RATINGS TABLE AS SOON AS DOCTOR REGISTERS

create or replace function doc2rating()
returns trigger
as
$$
begin
insert into doctor_rating (doctor_id, numratings, sumratings, average)
values (NEW.id, 0, 0, 0);
return new;
end;
$$
language plpgsql;

create trigger doc2ratingTrig
after insert
on doctor
for each row
execute procedure doc2rating();



TRIGGER TO CREATE ENTRY IN DOCTOR PATIENT REGISTRY AS SOON AS APPOINTMENT IS MADE

create or replace function app2reg()
returns trigger
as
$$
begin
if exists (select * from doctor_patient where doctor_id = NEW.doctor_id and patient_id = NEW.patient_id)
then
RAISE NOTICE 'Already listed';
else
insert into doctor_patient (doctor_id, patient_id, dateOfAssignment) values (NEW.doctor_id, NEW.patient_id, now());
end if;
return new;
end;
$$
language plpgsql;

create trigger app2regTrig
after insert
on appointment
for each row
execute procedure app2reg();



TRIGGER TO REMOVE ENTRY IN DOCTOR PATIENT REGISTRY IF APPOINTMENT IS CANCELLED BEFORE TAKING PLACE

create or replace function regRemove()
returns trigger
as
$$
declare
dateRegCmp date;
dateAppCmp date;
begin
dateAppCmp := OLD.dateOfAppointment;
select dateOfAssignment into dateRegCmp from doctor_patient where patient_id = OLD.patient_id and doctor_id = OLD.doctor_id;
RAISE NOTICE 'dateAppCmp = %, dateRegCmp = %', dateAppCmp, dateRegCmp;
if ( dateAppCmp > dateRegCmp )
then
delete from doctor_patient where doctor_id = OLD.doctor_id and patient_id = OLD.patient_id;
end if;
return new;
end;
$$
language plpgsql;

create trigger regRemoveTrig
after delete
on appointment
for each row
execute procedure regRemove();
